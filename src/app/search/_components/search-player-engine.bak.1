"use client";

import { useEffect, useLayoutEffect, useRef } from "react";
import youtubePlayer from "youtube-player";
import { useSongPlayer } from "@/app/search/_context/song-player-context";

type Song = {
  id: string;
  title: string;
  url: string;
  thumbnail: string;
  duration: { timestamp: string; seconds: number };
};

type SongPlayerEngineProps = {
  songs: Song[];
};

export function SongPlayerEngine({ songs }: SongPlayerEngineProps) {
  const {
    youtubeId,
    playerRef,
    setIsLoading,
    setDuration,
    setProgress,
    setIsPlaying,
    currentSong,
    setSong,
    isPlaying,
    mode,
  } = useSongPlayer();

  // host lives OUTSIDE React tree
  const hostRef = useRef<HTMLDivElement | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const currentSongRef = useRef<Song | null>(null);
  const modeRef = useRef(mode);
  const isPlayingRef = useRef(isPlaying);
  const lastTimeRef = useRef(0); // keeps track of last played time

  useEffect(() => {
    currentSongRef.current = currentSong;
  }, [currentSong]);

  useEffect(() => {
    modeRef.current = mode;
  }, [mode]);

  useEffect(() => {
    isPlayingRef.current = isPlaying;
  }, [isPlaying]);

  const clearProgressTimer = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  const handlePlayerStateChange = async (
    // biome-ignore lint/suspicious/noExplicitAny: YouTube event shape
    event: CustomEvent<any> & { data: number },
  ) => {
    if (!playerRef.current) return;

    switch (event.data) {
      case -1: // unstarted
        setIsLoading(true);
        break;
      case 1: {
        setIsLoading(false);
        const d = await playerRef.current.getDuration();
        setDuration(Number.isFinite(d) ? d : 0);
        setIsPlaying(true);
        break;
      }
      case 2:
        setIsPlaying(false);
        break;
      case 0: {
        const currentIndex = songs.findIndex(
          (s) => s.id === currentSongRef.current?.id,
        );

        if (!currentSongRef.current) {
          setIsPlaying(false);
          return;
        }

        if (modeRef.current === "repeat") {
          try {
            await playerRef.current.seekTo(0, true);
            await playerRef.current.playVideo();
          } catch (err) {
            console.warn("Error repeating song:", err);
          }
          return;
        }

        if (modeRef.current === "shuffle") {
          const otherSongs = songs.filter(
            (s) => s.id !== currentSongRef.current?.id,
          );
          if (otherSongs.length > 0) {
            const randomSong =
              otherSongs[Math.floor(Math.random() * otherSongs.length)];
            setSong(randomSong, randomSong.id);
          } else {
            setIsPlaying(false);
          }
          return;
        }

        // normal next
        if (currentIndex !== -1 && currentIndex < songs.length - 1) {
          const nextSong = songs[currentIndex + 1];
          setSong(nextSong, nextSong.id);
        } else {
          setIsPlaying(false);
        }
        break;
      }
    }
  };

  // Create a stable host outside React, and create/destroy the player there.
  useLayoutEffect(() => {
    // 1) Create host once and append to <body>
    if (!hostRef.current) {
      const host = document.createElement("div");
      host.id = "yt-audio-host";
      host.style.position = "fixed";
      host.style.inset = "0";
      host.style.width = "0px";
      host.style.height = "0px";
      host.style.overflow = "hidden";
      host.style.opacity = "0";
      host.style.pointerEvents = "none";
      document.body.appendChild(host);
      hostRef.current = host;
    }

    // 2) Create player once
    if (!playerRef.current && hostRef.current) {
      const player = youtubePlayer(hostRef.current, {
        width: 0,
        height: 0,
        playerVars: {
          autoplay: 0,
          controls: 0,
          rel: 0,
          playsinline: 1,
          // helps with CORS + iframe API in some Next setups
          origin: window.location.origin,
        },
      });

      player.on("stateChange", handlePlayerStateChange);
      playerRef.current = player;
    }

    // 3) Cleanup on true unmount
    return () => {
      clearProgressTimer();
      try {
        playerRef.current?.off?.("stateChange", handlePlayerStateChange);
      } catch {}
      try {
        playerRef.current?.destroy?.();
      } catch (e) {
        console.warn("YT destroy failed:", e);
      }
      playerRef.current = null;

      if (hostRef.current?.parentNode) {
        hostRef.current.parentNode.removeChild(hostRef.current);
      }
      hostRef.current = null;
    };
    // empty deps: run once; strict mode will double-invoke in dev but this pattern is fine
  }, []);

  // Drive progress polling
  useEffect(() => {
    clearProgressTimer();

    if (playerRef.current && isPlaying) {
      intervalRef.current = setInterval(async () => {
        try {
          const t = await playerRef.current?.getCurrentTime();
          if (t != null) setProgress(t);
        } catch (err) {
          console.warn("Error getting current time:", err);
        }
      }, 1000);
    }
    return clearProgressTimer;
  }, [isPlaying, setProgress]);

  // Load a new video when youtubeId changes
  useEffect(() => {
    if (!playerRef.current || !youtubeId) return;

    setIsLoading(true);
    setProgress(0);
    playerRef.current.loadVideoById(youtubeId);
  }, [youtubeId, setIsLoading, setProgress]);

  useEffect(() => {
    clearProgressTimer();

    let lastProgressUpdate = 0;
    if (playerRef.current && isPlaying) {
      intervalRef.current = setInterval(async () => {
        try {
          const t = await playerRef.current?.getCurrentTime();
          if (t != null) {
            // setProgress(t);
            // lastTimeRef.current = t; // <--- save last time here
            lastTimeRef.current = t; // always track latest

            // throttle React updates
            const now = Date.now();
            if (now - lastProgressUpdate > 500) {
              setProgress(t);
              lastProgressUpdate = now;
            }
          }
        } catch (err) {
          console.warn("Error getting current time:", err);
        }
      }, 1000);
    }

    return clearProgressTimer;
  }, [isPlaying, setProgress]);

  useEffect(() => {
    if (!playerRef.current) return;

    const handleVisibility = async () => {
      if (document.hidden && isPlayingRef.current) {
        try {
          await playerRef.current?.seekTo(lastTimeRef.current, true);
          await playerRef.current?.playVideo();
        } catch (err) {
          console.warn("Autoplay blocked or failed resume:", err);
        }
      }
    };

    document.addEventListener("visibilitychange", handleVisibility);
    return () => {
      document.removeEventListener("visibilitychange", handleVisibility);
    };
  }, []);
  // // Try to auto-resume playback when tab regains focus
  // useEffect(() => {
  //   if (!playerRef.current) return;
  //
  //   let lastTime = 0;
  //
  //   // keep last known time updated
  //   const syncTime = async () => {
  //     try {
  //       const t = await playerRef.current?.getCurrentTime();
  //       if (typeof t === "number" && !Number.isNaN(t)) {
  //         lastTime = t;
  //       }
  //     } catch {}
  //   };
  //   const timeInterval = setInterval(syncTime, 1000);
  //
  //   const handleVisibility = async () => {
  //     if (document.hidden) {
  //       await syncTime();
  //       if (isPlayingRef.current) {
  //         setTimeout(async () => {
  //           try {
  //             await playerRef.current?.seekTo(lastTime, true);
  //             await playerRef.current?.playVideo();
  //           } catch (err) {
  //             console.warn("Autoplay blocked or failed resume:", err);
  //           }
  //         }, 200); // shorter delay feels more instant
  //       }
  //     }
  //   };
  //
  //   document.addEventListener("visibilitychange", handleVisibility);
  //
  //   return () => {
  //     clearInterval(timeInterval);
  //     document.removeEventListener("visibilitychange", handleVisibility);
  //   };
  // }, []);

  // // Sync Media Session API
  useEffect(() => {
    if (!("mediaSession" in navigator) || !currentSong) return;

    navigator.mediaSession.metadata = new MediaMetadata({
      title: currentSong.title,
      artist: "Unknown Artist",
      album: "Moodifyr",
      artwork: [
        { src: currentSong.thumbnail, sizes: "512x512", type: "image/png" },
      ],
    });

    navigator.mediaSession.playbackState = isPlaying ? "playing" : "paused";

    navigator.mediaSession.setActionHandler("play", () => {
      playerRef.current?.playVideo();
    });
    navigator.mediaSession.setActionHandler("pause", () => {
      playerRef.current?.pauseVideo();
    });
    navigator.mediaSession.setActionHandler("nexttrack", () => {
      const idx = songs.findIndex((s) => s.id === currentSong.id);
      if (idx !== -1 && idx < songs.length - 1) {
        const next = songs[idx + 1];
        setSong(next, next.id);
      }
    });
    navigator.mediaSession.setActionHandler("previoustrack", () => {
      const idx = songs.findIndex((s) => s.id === currentSong.id);
      if (idx > 0) {
        const prev = songs[idx - 1];
        setSong(prev, prev.id);
      }
    });
  }, [currentSong, isPlaying, songs, setSong]);

  // We don’t render anything—player lives in document.body
  return null;
}
