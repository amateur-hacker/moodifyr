"use client";

import { useEffect, useRef } from "react";
import YoutubePlayer from "youtube-player";
import { useSongPlayer } from "@/app/search/_context/song-player-context";

type Song = {
  id: string;
  title: string;
  url: string;
  thumbnail: string;
  duration: { timestamp: string; seconds: number };
};

type SongPlayerEngineProps = {
  songs: Song[];
};

export function SongPlayerEngine({ songs }: SongPlayerEngineProps) {
  const {
    youtubeId,
    playerRef,
    setIsLoading,
    setDuration,
    setProgress,
    setIsPlaying,
    currentSong,
    setSong,
    isPlaying,
    mode,
  } = useSongPlayer();

  const containerRef = useRef<HTMLDivElement>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const currentSongRef = useRef<Song | null>(null);
  const modeRef = useRef(mode);

  useEffect(() => {
    currentSongRef.current = currentSong;
  }, [currentSong]);

  useEffect(() => {
    modeRef.current = mode;
  }, [mode]);

  const clearProgressTimer = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  const handlePlayerStateChange = async (
    // biome-ignore lint/suspicious/noExplicitAny: <supress any type error>
    event: CustomEvent<any> & {
      data: number;
    },
  ) => {
    if (!playerRef.current) return;

    switch (event.data) {
      case 1: {
        setIsLoading(false);
        const d = await playerRef.current.getDuration();
        setDuration(d);
        setIsPlaying(true);
        break;
      }
      case 2:
        setIsPlaying(false);
        break;
      case 0: {
        const currentIndex = songs.findIndex(
          (s) => s.id === currentSongRef.current?.id,
        );

        if (!currentSongRef.current) {
          setIsPlaying(false);
          return;
        }

        if (modeRef.current === "repeat") {
          try {
            // setSong(currentSongRef.current, currentSongRef.current.id);
            await playerRef.current.seekTo(0, true);
            await playerRef.current.playVideo();
          } catch (err) {
            console.warn("Error repeating song:", err);
          }
          return;
        }

        if (modeRef.current === "shuffle") {
          const otherSongs = songs.filter(
            (s) => s.id !== currentSongRef.current?.id,
          );
          if (otherSongs.length > 0) {
            const randomSong =
              otherSongs[Math.floor(Math.random() * otherSongs.length)];
            setSong(randomSong, randomSong.id);
          } else {
            setIsPlaying(false);
          }
          return;
        }

        // normal
        if (currentIndex !== -1 && currentIndex < songs.length - 1) {
          const nextSong = songs[currentIndex + 1];
          setSong(nextSong, nextSong.id);
        } else {
          setIsPlaying(false);
        }
        break;
      }
    }
  };

  // biome-ignore lint/correctness/useExhaustiveDependencies: <supress unnecessary dependencies error>
  useEffect(() => {
    if (!containerRef.current || playerRef.current) return;

    const player = YoutubePlayer(containerRef.current, {
      playerVars: { autoplay: 0, controls: 0 },
    });

    player.on("stateChange", handlePlayerStateChange);
    playerRef.current = player;

    return clearProgressTimer;
  }, []);

  // biome-ignore lint/correctness/useExhaustiveDependencies: <supress unnecessary dependencies error>
  useEffect(() => {
    clearProgressTimer();

    if (playerRef.current && isPlaying) {
      intervalRef.current = setInterval(async () => {
        try {
          const t = await playerRef.current?.getCurrentTime();
          if (t != null) setProgress(t);
        } catch (err) {
          console.warn("Error getting current time:", err);
        }
      }, 1000);
    }

    return clearProgressTimer;
  }, [isPlaying]);

  // biome-ignore lint/correctness/useExhaustiveDependencies: <supress unnecessary dependencies error>
  useEffect(() => {
    if (!playerRef.current || !youtubeId) return;

    setIsLoading(true);
    setProgress(0);
    playerRef.current.loadVideoById(youtubeId);
  }, [youtubeId]);

  return <div ref={containerRef} className="hidden" />;
}
