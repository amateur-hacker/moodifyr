import { BetterAuthError, type User as SessionUser } from "better-auth";
import { isRedirectError } from "next/dist/client/components/redirect-error";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";
import { getErrorMessage } from "@/lib/utils";

const withSession = async <T>({
  fn,
  isProtected = true,
  serverErrorMessage = "Error executing function",
}: {
  fn: ({ sessionUser }: { sessionUser?: SessionUser }) => Promise<T>;
  isProtected?: boolean;
  serverErrorMessage?: string;
}): Promise<T | null> => {
  try {
    let sessionUser: SessionUser | undefined;

    if (isProtected) {
      const session = await auth.api.getSession({ headers: await headers() });
      if (!session) throw new Error("User not authorized!");
      sessionUser = session.user as SessionUser;
    }

    return await fn({ sessionUser });
  } catch (error) {
    if (isRedirectError(error)) throw error;
    console.error(serverErrorMessage, error);
    return null;
    // if (error instanceof BetterAuthError) return null;
    // if (error instanceof Error) throw error;
    // throw new Error(serverErrorMessage);
  }
};

type ActionResult = { success: boolean; message: string };

const executeAction = async <T>({
  actionFn,
  clientSuccessMessage = "Operation was successful",
  serverErrorMessage = "Error executing action",
  isProtected = true,
}: {
  actionFn: ({ sessionUser }: { sessionUser?: SessionUser }) => Promise<T>;
  clientSuccessMessage?: string;
  serverErrorMessage?: string;
  isProtected?: boolean;
}): Promise<ActionResult> => {
  try {
    await withSession({ fn: actionFn, isProtected, serverErrorMessage });
    return { success: true, message: clientSuccessMessage };
  } catch (error) {
    console.error(serverErrorMessage, error);
    return { success: false, message: getErrorMessage(error) };
  }
};

const executeFn = async <T>({
  fn,
  isProtected = true,
  serverErrorMessage = "Error executing function",
}: {
  fn: ({ sessionUser }: { sessionUser?: SessionUser }) => Promise<T>;
  isProtected?: boolean;
  serverErrorMessage?: string;
}): Promise<T | null> => {
  return withSession({ fn, isProtected, serverErrorMessage });
};

const executeQuery = async <T>({
  queryFn,
  isProtected = true,
  serverErrorMessage = "Error executing query",
}: {
  queryFn: ({ sessionUser }: { sessionUser?: SessionUser }) => Promise<T>;
  isProtected?: boolean;
  serverErrorMessage?: string;
}): Promise<T | null> => {
  return withSession({ fn: queryFn, isProtected, serverErrorMessage });
};

const executeApi = async <T>({
  apiFn,
  isProtected = true,
  serverErrorMessage = "Error executing API request",
}: {
  apiFn: ({ sessionUser }: { sessionUser?: SessionUser }) => Promise<T>;
  isProtected?: boolean;
  serverErrorMessage?: string;
}): Promise<T | null> => {
  return withSession({ fn: apiFn, isProtected, serverErrorMessage });
};

export { executeAction, executeFn, executeQuery, executeApi };
